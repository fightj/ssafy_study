# 0806 스택1
1. 스택
2. 재귀호출
3. 재귀호출 연습
4. Memoization
5. Dp
6. DFS  

## 1. 스택
1. 연산
   - 삽입: push
   - 삭제: pop
   - 스택이 공백인지 아닌지를 확인하는 연산 .isEmpty
   - 스택의 top에 있는 item(원소)을 반환하는 연산.peek
2. 스택의 구현
   ```python

   ```

3. 스택 구현 고려 사항
   - 1차원 배열을 사용하여 구현할 경우 구현이 용이하다는 장점이 있지만 스택의 크기를 변경하기가 어렵다는 단점이 있다.

4. 스택의 응용1: 괄호검사
   - 조건
   - 1 왼쪽 괄호의 개수와 오른쪽 괄호의 개수가 같아야 한다.
   - 2 같은 괄호에서 왼쪽 괄호는 오른쪽 괄호보다 먼저 나와야 한다.
   - 3 괄호 사이에는 포함 관계만 존재한다.
    ![alt text](image-3.png)
   - 문자열에 있는 괄호를 차례대로 조사하면서 왼쪽 괄호를 만나면 스택에 삽입하고, 오른쪽 괄호를 만나면 스택에서 top 괄호를 삭제한 후 오른쪽 괄호와 짝이 맞는지를 검사한다.

## 2. 재귀호출
1. 피보나치 수를 구하는 재귀함수
   ```python
   def fibo(n):
    if n < 2:
        return n
    else:
        return fibo(n-1) + fibo(n-2)    
   ```
## 3. 재귀호출 연습



재귀 + 백트래킹 --> DFS에 활용

큐: 선입선출
선출 --> pop(0) --> 단점이 시간복잡도가 O(N)
해결방안 : deque 모듈 사용, from collections import deque
선입 ---> append(), 선출 ---> popleft()
+ vistiter 배열 + 재귀 + 백트래킹 + used 가지치기 ... --> BFS에 활용

우선순위 큐
heapq 모듈 사용, import heapq
heappush: 가장 작은 요소가 항상 첫 번째 요소에 온다
heappop: 힙에서 가장 작은 요소를 제거
---> 다익스트라 알고리즘에 활용

DP
문제의 최적 부분 구조 파악
재귀적 구조
점화식
작은 문제부터 해결하여 결과에 저장 (Bottom-up)
큰 문제를 작은 문제로 나누며 해결 (Top-down)
저장된 결과를 이용해서 문제의 해를 구한다.